<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="theme-color" content="#0ea5e9">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Sign In - Xapo Bank</title>
  <link rel="icon" href="/xapo_logo.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="/xapo_logo.svg">
  <script src="https://cdn.tailwindcss.com"></script>
  
  <style>
    /* Minor overrides for better touch targets on small devices */
    input[type="email"], input[type="password"] { font-size: 1rem; }
    /* Ensure the sign-in card uses comfortable spacing on larger screens */
    @media (min-width: 768px) {
      .card { padding: 2.5rem; }
    }
    /* Toast notifications (centered, responsive) */
    #toast-container { position: fixed; left: 50%; top: 12%; transform: translateX(-50%); z-index: 9999; display:flex; flex-direction:column; gap:0.5rem; align-items:center; width: 100%; pointer-events: none; }
    #toast-container .toast { pointer-events: auto; max-width: 90vw; width: auto; }
    .toast { background: rgba(30,30,30,0.95); color: #e6e6e6; padding: 0.75rem 1rem; border-radius: 8px; box-shadow: 0 6px 18px rgba(0,0,0,0.4); min-width: 220px; max-width: 420px; font-size:0.95rem; display:flex; align-items:center; justify-content:space-between; gap:0.5rem; box-sizing:border-box; }
    .toast.info { border-left: 4px solid #0ea5e9; }
    .toast.success { border-left: 4px solid #10b981; }
    .toast.error { border-left: 4px solid #ef4444; }
    .toast .toast-actions { margin-left: 0.5rem; display:flex; gap:0.5rem; }
    .toast .btn { background:transparent; border:1px solid rgba(255,255,255,0.06); color:inherit; padding:6px 10px; border-radius:6px; cursor:pointer; }
    .toast .btn.primary { background:#0ea5e9; color:#051124; border:none; }
  </style>
</head>
<body class="bg-black text-slate-300 min-h-screen flex items-center justify-center py-8">
  <main class="w-full max-w-md px-4">
    <section class="bg-black rounded-2xl shadow-lg card mx-auto border border-black">
      <div class="p-6 sm:p-8">
        <header class="mb-6 text-center">
          <img src="/xapo_logo.svg" alt="Xapo Bank" class="mx-auto h-10 w-auto mb-3" onerror="this.style.display='none'">
          <h1 class="text-2xl font-semibold text-slate-100">Sign in to your account</h1>
        
        </header>

        <div id="signin-error" class="hidden mb-4 text-sm text-red-400"></div>
        <div id="open-external-wrap" class="hidden mb-4 text-sm text-center">
          <button id="open-external-btn" class="px-3 py-2 bg-slate-700 text-white rounded">Open in external browser</button>
        </div>
        <form id="signin-form" class="space-y-4" autocomplete="on">
          <div>
                     <label for="email" class="block text-sm font-medium text-slate-300 mb-1">Email</label>
                     <input inputmode="email" type="email" id="email" name="email" required
                       class="block w-full rounded-lg border border-slate-600 bg-black text-slate-300 px-4 py-3 focus:outline-none focus:ring-2 focus:ring-slate-500">
          </div>

          <div>
            <label for="password" class="block text-sm font-medium text-slate-300 mb-1">Password</label>
            <div class="relative">
              <input type="password" id="password" name="password" required
                class="block w-full rounded-lg border border-slate-600 bg-black text-slate-300 px-4 py-3 pr-12 focus:outline-none focus:ring-2 focus:ring-slate-500">
              <button type="button" id="toggle-password" aria-label="Show password"
                 class="absolute right-2 top-1/2 -translate-y-1/2 text-slate-400 text-sm p-2 rounded-md hover:bg-slate-800">
                Show
              </button>
            </div>
          </div>

          <div class="flex items-center justify-between text-sm">
            <label class="inline-flex items-center gap-2">
              <input type="checkbox" id="remember" class="h-4 w-4 rounded border-slate-600 bg-black">
              <span class="text-slate-300">Remember me</span>
            </label>
            <a href="#" id="forgot-link" class="text-slate-400 hover:underline">Forgot password?</a>
          </div>

          <div>
            <button type="submit" id="submit-btn" class="w-full bg-slate-600 text-slate-100 font-medium rounded-lg py-3 hover:bg-slate-700 active:scale-98">
              <span id="submit-text">Sign In</span>
              <span id="submit-loading" class="hidden">Signing in...</span>
            </button>
          </div>
        </form>

        <p class="mt-4 text-center text-sm text-slate-400">Don’t have an account? <a href="./signup.html" class="text-slate-400 hover:underline">Sign up</a></p>
      </div>
    </section>
  </main>

  <script>
    // Development helper: when loaded from localhost, point API_BASE to local backend
    try {
      if ((!window.API_BASE || window.API_BASE === '') && (location.hostname === 'localhost' || location.hostname === '127.0.0.1')) {
        window.API_BASE = location.protocol + '//' + location.hostname + ':' + (window.BACKEND_PORT || '10000');
        console.debug('DEV: setting window.API_BASE to', window.API_BASE);
      }
    } catch (e) { /* ignore */ }

    // Register service worker to proxy /api/* from static site to backend.
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js').then(reg => {
        console.debug('Service worker registered', reg);
        // Send API base to the worker when active
        const sendApiBase = (worker) => {
                try { worker.postMessage({ type: 'setApiBase', value: window.API_BASE || window.API_URL || 'https://backend-xapobank-1.onrender.com' }); } catch (e) {}
        };
        if (reg.installing) reg.installing.addEventListener('statechange', () => {});
        if (reg.waiting) sendApiBase(reg.waiting);
        if (reg.active) sendApiBase(reg.active);
      }).catch(err => console.warn('Service worker registration failed', err));
    }

    // If running inside Telegram Web App or other in-app browsers, offer an
    // explicit button to open the page in the external/system browser which
    // often avoids storage and proxy restrictions imposed by the host app.
    (function setupTelegramOpenExternal(){
      function show() {
        try {
          const ua = (navigator && navigator.userAgent) ? navigator.userAgent : '';
          const isTelegram = !!(window.Telegram && window.Telegram.WebApp) || /Telegram/i.test(ua);
          const isIos = /iPhone|iPad|iPod/i.test(ua);
          if (!isTelegram) return;
          // Notify Telegram SDK the web app is ready (if available)
          try { if (window.Telegram && window.Telegram.WebApp && typeof window.Telegram.WebApp.ready === 'function') window.Telegram.WebApp.ready(); } catch (e) {}
          const wrap = document.getElementById('open-external-wrap');
          if (!wrap) return;
          wrap.classList.remove('hidden');
          const btn = document.getElementById('open-external-btn');
          if (!btn) return;
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            try {
              if (window.Telegram && window.Telegram.WebApp && typeof window.Telegram.WebApp.openTelegramLink === 'function') {
                window.Telegram.WebApp.openTelegramLink(window.location.href);
              } else {
                window.open(window.location.href, '_blank');
              }
            } catch (err) {
              try { window.open(window.location.href, '_blank'); } catch (_) { location.href = window.location.href; }
            }
          });
          // If inside Telegram/iOS, unregister any service worker to avoid
          // in-app proxying/misrouting of API calls during sign-in.
          try {
            if (isIos || isTelegram) {
              if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(regs => {
                  regs.forEach(r => {
                    try { r.unregister().then(() => console.warn('Service worker unregistered for Telegram/iOS')); } catch(e) {}
                  });
                }).catch(() => {});
              }
            }
          } catch (e) { console.warn('sw unregister failed', e); }
        } catch (e) { console.warn('Telegram external open setup failed', e); }
      }
      // Run after DOMContentLoaded (script may be inserted before DOM ready)
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', show); else show();
    })();

    // tryFetch: attempt to call backend, preferring explicit backend origin when
    // inside Telegram or iOS in-app browsers to avoid HTML fallback pages.
    async function tryFetch(path, opts){
      const ua = (typeof navigator !== 'undefined' && navigator.userAgent) ? navigator.userAgent : '';
      const isTelegram = (typeof window !== 'undefined') && ((window.Telegram && window.Telegram.WebApp) || /Telegram/i.test(ua));
      const isIos = /iPhone|iPad|iPod/i.test(ua);
      const API_BASE = (window.API_BASE || window.API_URL || '').replace(/\/$/, '');

      const candidates = [];
      if (isTelegram || isIos) {
        if (API_BASE) candidates.push(API_BASE + path);
        candidates.push(path);
      } else {
        candidates.push(path);
        if (API_BASE) candidates.push(API_BASE + path);
      }

      // Merge headers and prefer JSON
      const defaultHeaders = new Headers({ 'Accept': 'application/json' });
      if (opts && opts.headers) {
        try {
          const provided = new Headers(opts.headers);
          for (const [k, v] of provided.entries()) defaultHeaders.set(k, v);
        } catch (e) {
          try { Object.entries(opts.headers).forEach(([k, v]) => defaultHeaders.set(k, v)); } catch(_) {}
        }
      }

      let lastErr = null;
      for (const url of candidates) {
        try {
          console.debug('tryFetch ->', url);
          const init = Object.assign({}, opts, { headers: defaultHeaders });
          const resp = await fetch(url, init);
          // If response looks like HTML (static site) rather than JSON, try the explicit API_BASE
          try {
            const ct = resp && resp.headers && typeof resp.headers.get === 'function' ? (resp.headers.get('content-type') || '') : '';
            const isHtml = ct && /html/i.test(ct);
            // If we got HTML and we have an API_BASE candidate later, skip this response and try next
            if (isHtml) {
              console.warn('tryFetch: received HTML response, likely static host; will try next candidate', { url, contentType: ct });
              lastErr = new Error('received HTML response');
              // continue to next candidate (do not return this response)
              continue;
            }
          } catch (e) { /* ignore header parse errors and fall back to returning the response */ }
          return resp;
        } catch (e) {
          lastErr = e;
        }
      }
      throw lastErr || new Error('fetch failed');
    }
    // Toggle password visibility (guard elements exist)
    (function(){
      const toggleBtn = document.getElementById('toggle-password');
      const passwordInput = document.getElementById('password');
      if (!toggleBtn || !passwordInput) {
        console.warn('Password toggle elements not found; skipping listener');
        return;
      }
      toggleBtn.addEventListener('click', () => {
        if (passwordInput.type === 'password') {
          passwordInput.type = 'text';
          toggleBtn.textContent = 'Hide';
          toggleBtn.setAttribute('aria-pressed', 'true');
        } else {
          passwordInput.type = 'password';
          toggleBtn.textContent = 'Show';
          toggleBtn.setAttribute('aria-pressed', 'false');
        }
      });
    })();

    // Lightweight non-blocking toast UI
    (function(){
      const container = document.createElement('div');
      container.id = 'toast-container';
      document.body.appendChild(container);

      window.showToast = function(message, opts = {}) {
        const { type = 'info', duration = 4000, actions = [] } = opts;
        return new Promise((resolve) => {
              const t = document.createElement('div');
              t.className = `toast ${type}`;
              const text = document.createElement('div');
              text.style.flex = '1';
              text.textContent = message;
              t.appendChild(text);
              const actionsWrap = document.createElement('div');
              actionsWrap.className = 'toast-actions';
              if (Array.isArray(actions) && actions.length) {
                actions.forEach(a => {
                  const btn = document.createElement('button');
                  btn.className = 'btn' + (a.primary ? ' primary' : '');
                  btn.textContent = a.text || 'OK';
                  btn.addEventListener('click', () => {
                    clear();
                    resolve(a.value || a.text || 'action');
                  });
                  actionsWrap.appendChild(btn);
                });
                t.appendChild(actionsWrap);
              }
              // close control
              const closeBtn = document.createElement('button');
              closeBtn.className = 'btn';
              closeBtn.textContent = '×';
              closeBtn.title = 'Close';
              closeBtn.style.marginLeft = '8px';
              closeBtn.addEventListener('click', () => { clear(); resolve('closed'); });
              t.appendChild(closeBtn);

          let timeout = null;
          function clear() {
            if (timeout) clearTimeout(timeout);
            try { t.remove(); } catch (e) {}
          }

          container.appendChild(t);
          if (!actions.length) {
            timeout = setTimeout(() => { clear(); resolve('timeout'); }, duration);
          }
        });
      };
    })();

    // If running inside Telegram WebApp and initData is available, attempt
    // to exchange it for an app token automatically (bypasses email/password).
    (function tryTelegramAutoLogin(){
      try {
        const tg = (window && window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
        const initData = tg && (tg.initData || tg.initDataUnsafe || window.initData) ? (tg.initData || tg.initDataUnsafe || window.initData) : null;
        if (!initData) return;
        // Show a friendly message while attempting Telegram login
        try { window.showToast('Signing in with Telegram…', { type: 'info', duration: 3000 }); } catch (e) {}
        (async function(){
          try {
            const res = await tryFetch('/api/auth/telegram', {
              method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Bypass-SW': '1' },
              body: JSON.stringify({ initData })
            });
            const json = await res.json().catch(() => null);
            if (res && res.ok && json && json.token) {
              try { localStorage.setItem('token', json.token); } catch (e) { document.cookie = 'token=' + encodeURIComponent(json.token) + '; path=/'; }
              try { if (json.data) localStorage.setItem('user', JSON.stringify(json.data)); } catch (e) {}
              window.location.href = '/';
              return;
            }
            // If Telegram login failed, leave the page for manual login and show error
            const errDiv = document.getElementById('signin-error');
            const msg = (json && (json.message || json.error)) ? (json.message || json.error) : (res && res.statusText) || 'Telegram login failed';
            if (errDiv) { errDiv.textContent = msg; errDiv.classList.remove('hidden'); } else { alert(msg); }
          } catch (e) {
            console.warn('Telegram auto-login failed', e && e.message ? e.message : e);
          }
        })();
      } catch (e) { /* ignore */ }
    })();

    // Forgot password flow: non-blocking confirmation via toast
    document.getElementById('forgot-link').addEventListener('click', async (e) => {
      e.preventDefault();
      const emailInput = document.getElementById('email');
      let email = (emailInput.value && emailInput.value.trim()) || '';
      if (!email) {
        email = prompt('Enter your registered account email to receive password reset instructions:');
        if (!email) return;
      }

      const choice = await window.showToast(`Send password reset instructions to ${email}?`, { type: 'info', duration: 0, actions: [ { text: 'Cancel', value: 'cancel' }, { text: 'Send', value: 'send', primary: true } ] });
      if (choice !== 'send') return;

      try {
        const res = await tryFetch('/api/auth/forgot', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email })
        });
        if (res && res.ok) {
          await window.showToast('Password reset instructions have been sent to your registered email address. Please check your inbox.', { type: 'success', duration: 5000 });
        } else {
          await window.showToast('If that email is registered with us, you will receive password reset instructions shortly.', { type: 'info', duration: 5000 });
        }
      } catch (err) {
        console.error(err);
        await window.showToast('Unable to send reset email — try again later', { type: 'error', duration: 5000 });
      }
    });

    // Handle submit with loading state
    document.getElementById('signin-form').addEventListener('submit', async (event) => {
      event.preventDefault();
      const submitBtn = document.getElementById('submit-btn');
      const submitText = document.getElementById('submit-text');
      const submitLoading = document.getElementById('submit-loading');

      submitText.classList.add('hidden');
      submitLoading.classList.remove('hidden');
      submitBtn.disabled = true;

      const formData = {
        email: document.getElementById('email').value,
        password: document.getElementById('password').value
      };

      try {
        // Use tryFetch to handle proxying via service worker if needed
        const response = await tryFetch('/api/auth/login', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(formData),
        });
        if (!response) {
          const errDiv = document.getElementById('signin-error');
          const msg = 'Login request failed — no response from server (network/CORS/proxy issue).';
          console.warn(msg);
          if (errDiv) { errDiv.textContent = msg; errDiv.classList.remove('hidden'); }
          throw new Error(msg);
        }
        try {
          const ct = (response && response.headers && typeof response.headers.get === 'function') ? response.headers.get('content-type') : '';
          console.debug('Login response url/content-type', response && response.url, ct);
        } catch (e) {}
        let data;
        let rawText = null;
        try {
          data = await response.json();
        } catch (e) {
          // If server returned non-JSON, attempt to read the text and parse as JSON
          try {
            const txt = await response.text();
            const txtStripped = txt.replace(/^\uFEFF/, '').trim();
            rawText = txtStripped;
            try {
              data = JSON.parse(txtStripped);
              console.warn('Parsed JSON from non-standard response body', data);
            } catch (parseErr) {
              console.warn('Login response not JSON:', txtStripped);
              data = null;
            }
          } catch (_) {
            data = null;
          }
        }
        console.debug('Login response:', { status: response.status, ok: response.ok, body: data });
        if (response.ok) {
          const extractTokenFromResponse = (dataObj, resp) => {
            try {
              // common locations
              if (!dataObj) dataObj = null;
              const cand = (dataObj && (dataObj.token || dataObj.accessToken || dataObj.access_token))
                || (dataObj && dataObj.data && (dataObj.data.token || dataObj.data.accessToken || dataObj.data.access_token))
                || null;
              if (cand) return String(cand);
              // headers (e.g., x-auth-token or authorization)
              if (resp && resp.headers && typeof resp.headers.get === 'function') {
                const h = resp.headers.get('x-auth-token') || resp.headers.get('x-token') || resp.headers.get('authorization') || resp.headers.get('x-access-token');
                if (h) return String(h).replace(/^Bearer\s+/i, '').trim();
              }
              // cookie fallback (server might set cookie instead of JSON)
              try {
                const m = (document && document.cookie) ? document.cookie.match(/(?:^|; )token=([^;]+)/) : null;
                if (m && m[1]) return decodeURIComponent(m[1]);
              } catch (e) {}
            } catch (e) { console.warn('token extraction failed', e); }
            return '';
          };

          const tokenVal = extractTokenFromResponse(data, response) || '';
          if (!tokenVal) {
            const msg = 'Login succeeded but server did not return a token.';
            // Collect extra diagnostics: status, URL, and specific headers we add on the server
            let respHeaders = {};
            try {
              respHeaders = {
                'content-type': response.headers && typeof response.headers.get === 'function' ? response.headers.get('content-type') : '',
                'x-token-present': response.headers && typeof response.headers.get === 'function' ? response.headers.get('x-token-present') : '',
                'x-token-length': response.headers && typeof response.headers.get === 'function' ? response.headers.get('x-token-length') : ''
              };
            } catch (e) { respHeaders = {}; }
            console.warn(msg, { status: response && response.status, url: response && response.url, ok: response && response.ok, headers: respHeaders, body: data, rawText });
            const errDiv = document.getElementById('signin-error');
            const detailText = rawText || (data ? JSON.stringify(data) : '');
            const combined = `${msg} (status=${response && response.status}, x-token-present=${respHeaders['x-token-present'] || 'unknown'})` + (detailText ? ` — ${detailText}` : '');
            if (errDiv) {
              errDiv.textContent = combined;
              errDiv.classList.remove('hidden');
            } else {
              alert(combined);
            }
            // If response appears opaque or empty (no headers/body), try detecting cookie/session auth
            (async function tryDetectCookieSession() {
              try {
                const respType = response && response.type ? response.type : ''; // e.g., 'opaque'
                const ctHeader = response && response.headers && typeof response.headers.get === 'function' ? response.headers.get('content-type') : '';
                if (respType === 'opaque' || (!ctHeader && !rawText && !data)) {
                  const API_BASE = (window.API_BASE || window.API_URL || '').replace(/\/$/, '');
                  const hostsToTry = [];
                  if (API_BASE) hostsToTry.push(API_BASE);
                  try { hostsToTry.push(window.location.origin); } catch(_) {}
                  for (const h of hostsToTry) {
                    try {
                      const meResp = await fetch(h + '/api/auth/me', { method: 'GET', credentials: 'include', headers: { 'Accept': 'application/json', 'X-Bypass-SW': '1' } });
                      if (meResp && meResp.ok) {
                        let meJson = null;
                        try { meJson = await meResp.json(); } catch(_) { meJson = null; }
                        if (meJson) {
                          try { if (meJson && (meJson.data || meJson.user)) localStorage.setItem('user', JSON.stringify(meJson.data || meJson.user)); } catch (e) {}
                          try { localStorage.setItem('__session', 'cookie'); } catch (e) {}
                          window.location.href = '/';
                          return;
                        }
                      }
                    } catch (e) {
                      console.warn('Cookie/session detection fetch failed for', h, e && e.message ? e.message : e);
                    }
                  }
                }
              } catch (e) { console.warn('tryDetectCookieSession failed', e); }
            })();
            try { if (data && data.data) localStorage.setItem('user', JSON.stringify(data.data)); } catch (e) { console.warn('Could not store user', e); }

            // Diagnostic: try a direct fetch to the explicit backend origin to bypass
            // service workers or in-app browser proxies which may alter responses.
            (async function tryDirectLogin() {
              try {
                const API_BASE = (window.API_BASE || window.API_URL || '').replace(/\/$/, '');
                if (!API_BASE) return;
                const directResp = await fetch(API_BASE + '/api/auth/login', {
                  method: 'POST', headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(formData), cache: 'no-store'
                });
                let directData = null;
                let directText = null;
                try { directData = await directResp.json(); } catch (e) { try { directText = await directResp.text(); } catch(_) { directText = String(directResp.status); } }
                console.warn('Direct login attempt response:', directResp.status, directData || directText);
                // If direct attempt yields a token, persist it and redirect
                if (directData && directData.token) {
                  try { localStorage.setItem('token', directData.token); } catch (e) {
                    try {
                      const cookieStr = 'token=' + encodeURIComponent(directData.token) + '; path=/; max-age=' + (7*24*60*60) + (location.protocol === 'https:' ? '; SameSite=None; Secure' : '');
                      document.cookie = cookieStr;
                    } catch (ee) { console.warn('Cookie set failed', ee); }
                  }
                  try { if (directData && directData.data) localStorage.setItem('user', JSON.stringify(directData.data)); } catch (e) {}
                  window.location.href = '/';
                  return;
                }

                // If direct attempt did not return a token, try detecting cookie/session-based auth
                try {
                  const meResp = await fetch(API_BASE + '/api/auth/me', { method: 'GET', credentials: 'include', headers: { 'Accept': 'application/json' } });
                  let meJson = null;
                  try { meJson = await meResp.json(); } catch (_) { meJson = null; }
                  if (meResp && meResp.ok && meJson) {
                    try { if (meJson && (meJson.data || meJson.user)) localStorage.setItem('user', JSON.stringify(meJson.data || meJson.user)); } catch (e) {}
                    // mark that server uses cookie session (no token) so client can proceed
                    try { localStorage.setItem('__session', 'cookie'); } catch (e) {}
                    window.location.href = '/';
                    return;
                  }
                } catch (e) {
                  console.warn('Cookie/session detection attempt failed', e && e.message ? e.message : e);
                }

                // Show more details to the user so they can report it (useful for in-app browsers)
                const directDetail = directData ? JSON.stringify(directData) : (directText || directResp.statusText || String(directResp.status));
                if (errDiv) {
                  errDiv.textContent = `${msg} (direct attempt): ${directDetail}`;
                  errDiv.classList.remove('hidden');
                } else {
                  alert(`${msg} (direct attempt): ${directDetail}`);
                }
              } catch (e) {
                console.warn('Direct login attempt failed', e && e.message ? e.message : e);
              }
            })();
          } else {
            console.debug('Received token from server (redacted):', typeof tokenVal === 'string' ? '[REDACTED]' : tokenVal);
            // Attempt to persist token in localStorage, fall back to cookie if storage is blocked
            try {
              localStorage.setItem('token', tokenVal);
            } catch (err) {
              console.warn('localStorage.setItem failed — falling back to cookie', err && err.message ? err.message : err);
              try {
                const cookieStr = 'token=' + encodeURIComponent(tokenVal) + '; path=/; max-age=' + (7 * 24 * 60 * 60) + (location.protocol === 'https:' ? '; SameSite=None; Secure' : '');
                document.cookie = cookieStr;
              } catch (e) {
                console.warn('Cookie fallback failed', e && e.message ? e.message : e);
              }
            }
            try { if (data && data.data) localStorage.setItem('user', JSON.stringify(data.data)); } catch (e) { console.warn('Could not store user', e); }
            console.debug('Token persisted (storage fallback attempted), redirecting to /');
            window.location.href = '/';
          }
        } else {
          const msg = (data && (data.message || data.error)) ? (data.message || data.error) : (response.statusText || `Sign-in failed (${response.status})`);
          const errDiv = document.getElementById('signin-error');
          if (errDiv) {
            errDiv.textContent = msg;
            errDiv.classList.remove('hidden');
          } else {
            alert(msg);
          }
        }
      } catch (err) {
        console.error(err);
        alert('Network error — please try again.');
      } finally {
        submitText.classList.remove('hidden');
        submitLoading.classList.add('hidden');
        submitBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
